### ✅ 자바 직렬화의 대안을 찾으라

직렬화(Serialization)란 객체(그래프)를 [바이트 스트림](https://www.devkuma.com/docs/java/byte-stream/)으로 변환하여 저장하거나 **전송할 수 있게** 만들고,
나중에 그 바이트 스트림을 역직렬화로 다시 객체로 복원하는 메커니즘을 말합니다.

직렬화의 과정에서 생성자가 보이지 않는 방식으로 객체가 만들어지고, API와 내부 구현 사이의 경계가 모호해지며,
잠재적인 정확성 문제, 성능 저하, 보안 취약점, 그리고 유지 보수성의 어려움 등 명확한 단점들이 있었음에도 불구하고,
객체를 파일 저장이나 네트워크 전송을 위해 별도의 파싱 작업 없이 쉽게 바이트 스트림으로 변환해주는 압도적인 편리성과 장점 때문에 그 모든 단점을 감수하고 사용하는 사람들이 있었습니다.

### 직렬화의 근본적인 문제

> 공격 범위가 너무 넓고 지속적으로 더 넓어져 방어하기 어렵다는 점

직렬화의 공격 범위가 넓은 근본적인 이유는 `ObjectInputStream.readObject()` 메서드에 있으며,
이 메서드는 `Serializable` 타입에 정의된 **`readObject()`나 `readResolve()` 같은 훅(Hook)** 을 자동으로 실행해
정식 생성자를 거치지 않고도 객체 그래프를 복원하면서 임의 코드가 실행될 수 있는 위험을 내포하고 있을 뿐 아니라,
외부 바이트 스트림을 해석해 객체로 복원하는 역직렬화 과정에서 `Serializable` 인터페이스를 구현한 클래스패스
안의 거의 모든 타입의 객체를 만들어낼 수 있는 사실상 '마법 같은 생성자' 역할을 하므로, 바이트 스트림을 역직렬화하는 도중에 해당 타입들 안에 있는
모든 코드를 수행할 수 있게 되어 결과적으로 자바 표준
라이브러리나 서드파티 라이브러리는 물론 애플리케이션 자신의 클래스들까지 그 타입들의 코드 전체가 공격 범위에 포함되는 것입니다.

심지어 관련 모든 모범 사례를 적용하고 모든 직렬화 가능 클래스들을 공격에 대비해 신중하게 작성한다고 하더라도, 애플리케이션은 여전히 취약한 상태로 남을 수 있으므로,
오직 아주 신중하게 제작되었다고 확신할 수 있는 바이트 스트림만 역직렬화해야 합니다.

### 가젯 (gadget)

가젯은 역직렬화 과정에서 호출되어 잠재적인 문제를 가지고 있는 메소드(코드)를 의미하며,
이런 가젯들을 연쇄적으로 이어 붙여 최종적으로 위험한 동작으로 이어지게 만든 흐름을 가젯 체인이라고 부릅니다.

### 역직렬화 폭탄 (deserializable bomb)

역직렬화에 시간이 오래 걸리는 짧은 스트림을 역직렬화하는 것만으로도 서비스 거부 공격에 쉽게 노출될 수 있습니다. 이런 스트림을 역직렬화 폭탄이라고 합니다.

역직렬화 폭탄은 역직렬화에 **시간이 오래 걸리는 짧은 바이트 스트림을 의미**하며,
이러한 스트림을 역직렬화하는 것만으로도 서비스 거부(DoS) 공격에 쉽게 노출될 수 있습니다.

#### **코드 예시**

```java

static byte[] bomb() {
    Set<Object> root = new HashSet<>();
    Set<Object> s1 = root;
    Set<Object> s2 = new HashSet<>();

    for (int i = 0; i < 100; i++) {
        Set<Object> t1 = new HashSet<>();
        Set<Object> t2 = new HashSet<>();

        t1.add("foo"); // t1을 t2와 다르게 만든다.
        s1.add(t1);
        s1.add(t2);
        s2.add(t1);

        s2.add(t2);
        s1 = t1;
        s2 = t2;
    }

    return serialize(root); // 간결하게 하기 위해 이 메서드의 코드는 생략함
}

```

객체 그래프는 201개의 HashSet 인스턴스로 구성되어 있으며, 각 인스턴스는 3개 이하의 객체 참조만을 가지고 있어
스트림의 전체 크기는 고작 5,744 바이트에 불과합니다. 하지만 이 스트림을 역직렬화하는 데 걸리는 시간은 태양이 소멸할 때까지도 끝나지 않을 것입니다.
물론 역직렬화가 끝없이 진행된다는 것도 큰 문제지만, 가장 심각한 문제점은 이처럼 **무언가 잘못되었다는 신호조차 외부에 주지 않았다**는 것입니다.

### 역직렬화 폭탄 대처 방법

#### 1. 권장 방법: 역직렬화를 사용하지 않기

가장 좋은 방법은 아무것도 역직렬화하지 않는 것이며, 이는 극단적인 방법으로 보일 수 있으나 객체와 바이트 시퀀스를 변환해주는
**크로스 플랫폼 구조화된 데이터 표현(cross-platform structured-data representation)** 이라는
다른 메커니즘이 워낙 많아 굳이 자바 직렬화를 써야 할 이유가 전혀 없기 때문인데 이 cross-platform structured-data representation 방식은 (직렬화
시스템이라고도 불리지만 책의 표현을 따라 사용) 기존 직렬화의 단점을 보완하면서도 참고 자료가 많다는 장점까지 갖추고 있습니다.

#### 2. 차선책: 신뢰할 수 없는 데이터는 절대 역직렬화하지 않을 것

자바의 **레거시 시스템** 때문에 불가피하게 직렬화를 사용해야 하는 경우가 있는데,
이런 경우 차선책으로 직렬화를 사용한다고 하더라도 **신뢰할 수 없는 데이터는 절대 사용하면 안 됩니다.**

특히 신뢰할 수 없는 발신원(출처, 외부 서버, 엔드 포인트)으로부터 **원격 메서드 호출(RMI)**은 절대 수용해서는 안 됩니다.
심지어 자바 공식 보안 문서에서도 신뢰할 수 없는 데이터의 역직렬화는 본질적으로 위험하므로 절대로 피해야 한다고 명시하고 있으며, 만약
자바 직렬화를 사용해야 하고 해당 데이터가 신뢰할 수 없다면 **자바 9에 추가된 역직렬화 필터링**을 사용하는 것이 좋습니다.

### 역직렬화 필터링

역직렬화 필터링은 **데이터 스트림이 역직렬화되기 이전에 필터를 설치하는 기능**으로, **클래스 단위**로 특정 클래스의 승인 또는 거부를 결정할 수 있으며,
기본 수용 모드에서 블랙리스트와 화이트리스트 기능을 모두 지원합니다. 하지만 블랙리스트 방식은 이미 알려진 위험으로부터만 보호할 수 있어 나중에 생기는 새로운 위험은 막을 수 없기 때문에,
화이트리스트 방식을 사용하는 것을 추천합니다

참고로, 화이트리스트를 자동으로 생성해주는 **스왓(SWAT)** 이라는 도구가 있는데 이는 시스템의 메모리를 과하게 사용하거나
객체 그래프가 너무 깊어지는 사태로부터 보호해주는 기능을 지원해주지만 직렬화 폭탄 자체를 해결해주지는 못합니다.

### 크로스 플랫폼 구조화된 데이터 표현(cross-platform structured-data representation)

크로스 플랫폼 구조회된 데이터의 가장 큰 장점은 간단한 추상화만으로도 아주 강력한 **분산 시스템을 구축**할 수 있다는 것입니다.
또한, 공통적으로 자바 직렬화보다 훨씬 간단하게 사용할 수 있다는 장점도 있지만
대신 일반 객체를 자동으로 직렬화/역직렬화하지 않고 속성-값 쌍의 집합으로 구성된 구조화된 객체를 사용해야 합니다.
단! 지원하는 타입은 기본 타입 및 몇 개의 배열 타입으로 제한된다는 제약이 있습니다.

#### 크로스 플랫폼 구조화된 데이터 표현(cross-platform structured-data representation) 대표적인 예시

| 구분     |                   JSON                    |      프로토콜 버퍼(Protocol Buffers or protobuf)      |
|--------|:-----------------------------------------:|:-----------------------------------------------:|
| 데이터 형식 |                  텍스트 기반                   |                      이진 표현                      |
| 효율성    | 텍스트 기반이므로 이진 형식보다 효율이 낮음 (용량 크고 처리 속도 느림) | 이진 표현으로 용량이 작아 효율이 좋고 (압축 및 전송 속도 우수) 처리 속도가 빠름 |
| 구조 정의  |   **오직 데이터 표현에만 사용**되며, 별도의 스키마 강제가 없음    |       **스키마(타입)** 를 제공하여 데이터 구조를 명확하게 강제        |
| 추가 기능  |                    없음                     |        사람이 읽을 수 있는 텍스트 표현(pbtxt) 형식도 지원         |

질문
객체 그래프가 왜 201개임?? 202개 아님??

답변
생성된 HashSet은 총 202개(root 1 + 초기 s2 1 + for문 t1,t2 200)이지만, 초기 s2는 root로부터 직접, 간접으로 참조하지 않아
직렬화 그래프에 포함되지 않으므로, 그래프에는 root 1 + 반복문에서 만든 200 = HashSet 201개만 들어갑니다.