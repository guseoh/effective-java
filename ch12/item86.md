## ✅ Serializable을 사용할 지는 신중히 결정하라


## 0. 들어가기 전
어떤 클래스의 인스턴스를 직렬화할 수 있게 하려면 클래스 선언에 `implements Serializable`만 덧붙이면 된다.

너무 쉽게 적용 가능해 프로그래머가 특별히 신경 쓸 게 없다는 오해가 생길 수 있지만, 사실 훨씬 더 복잡하다.

<br>

## 1. Serializable 구현의 문제점

### 문제점 1. 릴리스한 뒤에는 수정하기 어렵다.
>  Serializable 을 구현하면, 그 직렬화 형태 자체가 공개 API처럼 영구히 유지되어야 하는 계약이 된다.  
즉, 한 번 릴리스하면 클래스의 내부 구현을 쉽게 바꿀 수 없게 된다.

1. **직렬화 형태도 공개 API가 된다.**
- `Serializable` 을 구현한 직렬화된 바이트 스트림 구조는 외부 시스템이나 다른 JVM이 직접 사용하는 데이터 계약이 된다.
- 따라서 클래스가 널리 퍼지면, 그 직렬화 형태로 변경 불가능한 공개 API처럼 취급해야 한다.

2. **캡슐화가 깨진다.**
- 자바의 기본 직렬화 형태에서는 클래스의 `private`과 `package-private` 인스턴스 필드까지 모두 직렬화 형태에 포함시킨다.
- 달리 말하면, 외부에서 해당 필드들의 존재와 타입을 **역직렬화를 통해 알아낼 수 있다.**
- 즉, 내부 구현사항이 노출되어 정보 은닉(아이템 15)도 무력화된다.

3. **클래스 내부 구현을 손보면 원래의 직렬화 형태가 달라지게 된다.**
- 클래스의 필드를 추가·삭제하거나 이름을 바꾸면 직렬화 형태가 바뀐다.
- 그 결과, 구버전 객체를 직렬화한 데이터를 신버전 클래스에서 역직렬화할 수 없게 된다.

4. **원래의 직렬화 형태를 유지하면서 내부 표현을 바꿀 수 있지만 복잡하다.**
- `ObjectOutputStream.putFields()`/`ObjectInputStream.readFields()` 를 이용하면 원래의 직렬화 형태를 유지하면서 내부 표현을 바꿀 수 있다.
- 하지만 코드가 지저분해지며, 구현이 매우 복잡하다.
- 따라서 처음부터 직렬화 형태도 주의해서 설계해야 한다.

<br>

> 직렬화가 클래스 개선을 방해하는 예시 → 직렬 버전 UID(serial version UID)

- 모든 직렬화된 클래스는 `serialVersionUID`라는 이름의 `static final long` 필드로 고유 식별 번호를 부여받는다.
- 이 번호를 명시하지 않으면, 시스템이 런타임에 SHA-1를 적용해 자동으로 클래스 안에 생성해 넣는다.
- 이 값을 생성하는데는 클래스 이름, 구현한 인터페이스들, 컴파일러가 자동으로 생성해 넣은 값을 포함한 대부분의 클래스 멤버들이 포함된다.
    - 필드나 메서드가 추가되거나 수정된다면 UID 값도 변경되어 `InvalidClassException`이 발생한다.

<br>

### 문제점 2. 버그와 보안 구멍이 생길 위험이 높아진다.
> Serializable을 구현하면 역직렬화 과정에서 객체 생성이 일반적인 생성자 호출을 우회하기 때문에,   
> 불변식이 깨지거나 악성 데이터로 인해 취약점이 발생할 위험이 매우 크다.

1. **역직렬화는 “숨겨진 생성자 호출”이다.**
- 보통 객체는 생성자를 통해 초기화되지만, 역직렬화시에는 `readObject()` 메서드를 통해 JVM 내부 메커니즘으로 객체가 복원된다.
- 즉, **생성자가 전혀 호출되지 않는다.**

2. **심각한 취약점들**
- 자바 직렬화 취약점은 실제 보안 사고의 주요 원인 중 하나로 꼽힌다.
    - ex_ Spring, Apache Commons Collections 등
- 역직렬화는 네트워크로부터 데이터를 받을 때, 파일로부터 객체를 읽을 때 사용되기 때문에 외부 입력에 의해 쉽게 공격될 수 있다.

<br>

### 문제점 3. 신버전으로의 이식이 어렵다.
- 직렬화 가능 클래스가 수정되면 신버전 인스턴스를 직렬화한 후 구버전으로 직렬화할 수 있는지,
    - 그 반대도 가능한지 검사해야 한다.
- 따라서 **테스트해야 할 양이 직렬화 가능 클래스의 수와 릴리스 횟수에 비례해 증가한다.**
    - 양방향 직렬화/역직렬화가 모두 성공하고, 원래의 객체를 충실히 복제해내는지를 반드시 확인해야 한다.
    - 커스텀 직렬화 형태를 잘 설계했다면 이러한 테스트 부담을 줄일 수 있다.

<br>

## 2. 주의 사항

### 2.1 Serializable 구현 여부는 가볍게 결정할 사안이 아니다.
- 단, 자바 직렬화를 이용하는 프레임워크용으로 만든 클래스라면 선택의 여지가 없다.
    - `Serializable`을 반드시 구현해야 하는 다른 클래스의 컴포넌트로 쓰일 클래스도 마찬가지이다.
- 하지만 `Serializable` 구현에 따르는 비용도 적지 않다.
    - 클래스를 설계할 때마다 그 이득과 비용을 고려해야 한다.
- 역사적으로
    - `BigInteger`와 `Instant` 같은 ‘**값**’ 클래스와 컬렉션 클래스들은 `Serializable`를 구현한다.
    - 스레드 풀처럼 **‘동작**’하는 객체를 표현하는 클래스들은 대부분 `Serializable` 을 구현하지 않는다.

<br>

### 2.2 상속용으로 설계된 클래스, 인터페이스 대부분은 Serializable을 구현해서는 안 된다.
- `Serializable` 을 구현한 클래스만 지원하는 프레임워크를 사용하는 상황은 예외이다.
    - `Throwable`과 `Component`가 이에 해당되어 거의 쓰이지 않는 방식이다.
- 클래스의 인스턴스 필드가 직렬화와 확장이 모두 가능하다면 주의할 점이 있다.
    1. 인스턴스 필드 중 불변식을 보장할 것에는 하위 클래스에서 `finalize` 메서드를 재정의하지 못하도록 해야 한다.
        - 즉, `finalize` 메서드를 자신이 재정의하면서 `final`로 선언하면 된다.
        - `finalize` 공격(아이템 8)을 당하기 때문
    2. 인스턴스 필드 중 기본값(정수형은 0)으로 초기화되면 위배되는 불변식이 존재할 경우
        - 클래스에 `readObjectNoData` 메서드를 반드시 추가하자.
       ```java
        private void readObjectNoData() throws InvalidObjectException {
          throw new InvalidObjectException("스트림 데이터가 필요합니다");
       }
       ```
       
<br>

### 2.3 내부 클래스(아이템 24)는 직렬화를 구현하지 말아야 한다.
- 내부 클래스에 대한 기본 직렬화 형태는 분명하지가 않다.
    - 바깥 인스턴스의 참조와 유효 범위 안의 지역변수 값들을 저장하기 위해 컴파일러가 생성한 필드들이 자동으로 추가된다.
- 단, 정적 멤버 클래스는 `Serializable` 을 구현해도 된다.

<br>

## 3. 핵심 정리
- `Serializable` 은 선언하기는 쉽지만, 그건 눈속임일 뿐이다.
- 보호된 환경에서만 쓰일 클래스가 아니라면 `Serializable` 구현은 아주 신중해야 한다.