### ✅ 스트림은 주의해서 사용하라

자바 8에 추가된 스트림은 대량의 데이터 처리 작업(순차적 or 병렬적)을 돕습니다.

### 스트림의 기본 구조 - 스트림 생성

스트림은 객체 참조뿐만 아니라 기본 타입(int, long, double)의 배열도 처리할 수 있습니다.
기본 타입 전용 스트림인 `IntStream`, `LongStream`, `DoubleStream`을 제공합니다.

단! 스트림을 병렬로 처리하려면 `parallel()` 메소드를 사용하거나 `parallelStream()` 애초에 벙렬 스트림을 생성해야 합니다.

### 중간 연산

중간 연산은 원본 데이터를 원하는 형태로 가공하는 역할을 합니다. 이러한 연산들은 스트림을 새로운 스트림으로 변환하며,
여러 개를 체인 형태로 연결할 수 있다는 특징이 있습니다.

- **필터링:** 특정 조건을 만족하지 않는 요소를 걸러냅니다. (예: filter())
- **변환:** 각 요소에 함수를 적용하여 새로운 요소로 바꿉니다. (예: map())
- **정렬:** 스트림의 요소를 특정 기준에 따라 정렬합니다. (예: sorted())
- **자르기:** 스트림의 일부만을 선택하거나 건너뜁니다. (예: limit(), skip())

중간 연산을 거친 후의 스트림 요소 타입은 원래 스트림의 타입과 같을 수도 있고 다를 수도 있습니다.
예를 들어, `String` 타입의 스트림을 `Integer` 타입의 스트림으로 변환할 수 있습니다.

```java

@Test
void testStrToInteger() {
    List<String> stringList = Arrays.asList("1", "2", "3", "4", "5");

    // String -> Integer 타입으로 변환
    List<Integer> integerList = stringList.stream()
            .map(s -> Integer.parseInt(s))
            .collect(Collectors.toList());

    List<Integer> expectedList = Arrays.asList(1, 2, 3, 4, 5);
    assertEquals(expectedList, integerList);
}
```

**TMI**
스트림에서 메소드 체인은 플루언트 API를 이용

### 종단 연산

종단 연산은 스트림 파이프라인의 마지막 단계를 담당하며, 중간 연산의 모든 작업을 실행하고 최종 결과를 도출하는 역할을 합니다.
종단 연산이 호출되는 순간, 비로소 데이터 처리가 시작됩니다.

- **즉시 실행:** 종단 연산이 호출될 때 중간 연산들이 함께 실행됩니다. 이 방식을 *
  *[지연 연산(Lazy Evaluation)](https://medium.com/%40binitabharati/power-of-lazy-evaluation-with-java-streams-ba729a3c7134)
  ** 이라고 합니다.
- **스트림 소모:** 종단 연산은 스트림을 소모하기 때문에, 한 번 종단 연산을 수행한 스트림은 다시 사용할 수 없습니다.
- **단 하나의 존재:** 파이프라인에는 반드시 하나의 종단 연산만 존재해야 합니다.

### 스트림이 제공하는 추상 개념 2가지

책 앞 부분에 나오는 추상 개념에 대해서 살펴보겠습니다. 스트림은 복잡한 데이터 처리 과정을 두 가지 핵심 개념으로 표현합니다.

1. 스트림은 데이터 원소의 유한 혹은 무한 스퀀스를 뜻한다.  
   <br />
   스트림은 데이터가 메모리에 미리 저장된 형태가 아닌, **데이터의 연속적인 흐름**을 논리적 시퀀스를 추상화한 것입니다.
   여기서 시퀀스는 데이터가 메모리에 미리 저장된 배열이나 리스트와 달리, **요청이 있을 때마다 필요에 따라 생성되거나 처리되는 데이터(논리적인 순서)** 을 의미합니다.  
   <br />
    - **유한 스퀀스:** 일반적으로 `Collection`이나 배열에서 생성하는 스트림으로, 데이터의 시작과 끝이 정해져 있습니다.
    - **무한 스퀀스:** `Stream.generate()`나 `Stream.iterate()`와 같이 특정 로직을 반복하여 무한히 데이터를 생성할 수 있습니다.  
      <br />

2. 파이프라인은 이 원소들로 수행하는 연산 단계를 표현하는 개념  
   스트림에서 파이브라인은 스트림 생성, 중간 연산, 종단 연산의 세 단계로 구성됩니다.

즉, 스트림은 데이터의 연속적인 흐름을 추상화한 개념이고, 파이프라인은 그 흐름을 실제로 가공하고 처리하는 단계들의 연결 구조라고 할 수 있습니다.

### 스트림을 사용할 때 주의할 점

1. 스트림을 과하게 사용하면 코드의 가독성이 떨어질 수 있습니다.
2. 람다 매개변수 이름을 잘 정해서 작성해야 합니다.
    - **나쁜 예:** list.stream().map(x -> x.getName())
    - **좋은 예:** users.stream().map(user -> user.getName())
3. `char` 값들을 처리할 때는 스트림을 삼가는 편이 낫다.  
   `char`용 스트림을 지원하지 않을 뿐만 아니라, 내부적으로 `int` 타입으로 처리되어서 오류나 불 필요한 형 변환을 사용해야 합니다.

### 스트림을 사용하면 좋지 않은 상황 - 람다

스트림과 람다는 밀접한 관계를 가지고 있습니다. 왜냐하면 중간 연산의 메소드을은 일반적으로 람다 표현식을 쓰기 때문에 람다 표현식을 단점을 그대로 가집니다.

- 제어 흐름 키워드를 사용하지 못합니다. (`return`, `break`, `continue`)
- 코드 블록에서는 범위 안의 지역변수를 읽고 수정할 수 있다. 하지만 람다에서는 `final`이거나 사실상 `final`인 변수만 읽을 수 있고 지역변수를 수정하는 건 불가능하다.  
  왜냐하면 스트림이 병렬 처리를 지원하면서 발생할 수 있는 데이터 동시성 문제를 방지하기 위한 설계 때문에 지역 변수를 수정할 수 없습니다.

추가로 람다 표현식이랑 관련 없는 상황도 존재합니다.
스트림 파이프라인은 일단 한 값과 다른 값에 매핑하고 나면 원래의 값을 잃는 구조이기 때문에
한 데이터가 파이프라인의 여러 단계를 통과할 때 이 데이터의 각 단계에서의 값들에 동시에 접근하기 어렵습니다.  
해결 방법으로 원래 값과 새로운 값의 쌍을 저장하는 객체를 사용해 매핑하는 방법도 있지만 그럴바엔 개인적으로 스트림 보단 `for`문을 사용하는 게 좋다고 생각합니다.

### 반대로 스트림을 사용할 때 좋은 상황

- 원소들의 시퀀스를 일관되게 변환
- 원소들의 시퀀스를 필터링
- 원소들의 시퀀스를 하나의 연산을 사용해 결합한다.(더하기, 연결하기, 최솟값 구하기 등)
- 원소들의 시퀀스를 컬렉션에 모은다.(공통된 속성을 기준으로 묶기)
- 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다.
