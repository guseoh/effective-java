### ✅ 예외는 진짜 예외 상황에만 사용하라

#### 예외를 잘못 사용한 예시

```java

class Mountain {
    public void climb() throws InterruptedException {
        Thread.sleep(1000L);
        System.out.println("한걸음~");
    }
}

public static void main(String[] args) {
    List<Mountain> range = Arrays.asList(new Mountain(), new Mountain(), new Mountain());

    int i = 0;

    try {
        while (true) {
            range[i++].climb();
        }
    } catch (ArrayIndexOutOfBoundsException e) {
    }
}

```

해당 코드를 보면 `range` 배열의 원소를 무한 루프로 순회하다가 배열의 크기를 벗어나면 일부로
`ArrayIndexOutOfBoundsException` 예외를 발생해 무한 루프가 종료되는 정말 안 좋은 코드입니다.

이러한 코드의 가장 큰 문제는 가독성이 떨어지고, 예외를 처리하는 `catch` 구문이 많은 자원을 소모한다는 점입니다. 일반적으로 `main` 문에서는 다음과 같이 `for-each` 구문을 사용하여 코드를
작성합니다. 단 `catch` 블록을 만드는 것 자체는 자원을 많이 소모하지 않습니다. 예외가 실제로 던져졌을 때의 비용(스택 트레이스 채우기, 스택 언와인딩 등)이 많이 든다는 의미입니다.

```java

public static void main(String[] args) {
    List<Mountain> range = Arrays.asList(new Mountain(), new Mountain(), new Mountain());
    for (Mountain m : range) {
        m.climb();
    }
}


```

### 그럼 예외를 이상하게 사용한 이유는 무엇일까??

배열 반목문 처리를 예외를 루프 종료 수단으로 활용하는 이유는 일반적으로 성능을 높이려고 한 것입니다.
`JVM`은 배열에 접근할 때 마다 배열의 경계를 벗어나지 않았는지를 검사하는 **경계 검사(Boundary Check)** 를 수행합니다.

반면, 일반적인 반복문(for or while)을 사용할 때는 코드에 배열의 경계(`xxx.size()`)에 도달하면 루프를 종료하도록 조건을 명시합니다.

즉, `JVM`이 이미 내부적으로 배열 경계 검사를 수행하는데 반복문에 종료 조건을 명시하는 것은 같은 일을 중복해서 하는 것이므로, **반복문 종료 조건을 생략하고 예외가 발생했을 때
종료하는 것이 성능을 조금이라도 높일 수 있다고 판단**했을 수 있습니다. 하지만 3가지 이유로 인해 잘못된 방법입니다.

1. 예외는 '예외적인 상황'을 위한 것이며, 성능 최적화를 위해 사용하기에는 동기가 약합니다.
2. 코드를 try-catch 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한된다.
    1. try-catch 블록으로 감싸면, JVM이 코드를 실행하기 전에 성능을 높이기 위해 수행하는 **다양한 고급 최적화(Optimization)** 를 방해
3. 표준적인 반목문 관용구는 앞서 걱정한 중복 검사를 걱정할 필요가 없습니다. JVM이 알아서 최적화해 없애준다.

### 예외의 본질 - 예외는 알맞는 예외 상황에만 사용하라 (흐름 제어의 대안이 될 수 없다)

위의 세 가지 문제 외에도 또 다른 문제가 존재합니다. 예외가 올바르게 동작하지 않을 수 있다는 점입니다. 반복문 내부에 다른 버그가 숨어 있는 경우,
이를 루프 종료 조건으로 사용하면 예외가 해당 버그를 숨기고 전혀 관련 없는 `ArrayIndexOutOfBoundsException`을 발생시킬 수 있습니다.

물론 더 포괄적인 예외 처리를 통해 이를 해결할 수도 있지만 그렇게 하면 코드의 가독성이 떨어지고 설령 성능이 일시적으로 개선되더라도
`Java` 자체가 지속적으로 발전하고 있기 때문에 그 성능상의 이점이 오래 유지되지 않을 가능성이 큽니다.

이런 문제점은 API를 설계할 때 중요한 원칙입니다.

### 좋은 API 설계 원칙 - API는 클라이언트에게 예외를 숨겨서 편하게 사용하게 하라

훌륭한 API는 클라이언트가 정상적인 흐름에서 예외를 사용하도록 허용해서는 안 됩니다.
즉, 예외를 제어 흐름의 수단으로 사용해서는 안 됩니다.
특정 상태에서만 호출할 수 있는 **상태 의존적(state-dependent)** 메서드를 제공하는 클래스라면,
반드시 그 상태를 확인할 수 있는 **상태 확인(state-checking)** 메서드도 함께 제공해야 합니다.

예를 들어, `Iterator` 인터페이스의 `next` 메서드와 `hasNext` 메서드가 있습니다.

- **상태 의존적 메서드:** 클래스의 **특정 내부 상태**가 충족될 때만 정상적으로 호출 및 실행이 보장되는 메서드 만약 해당 메서드가 요구하는 내부 상태가 충족되지 않은 상태에서 호출되면, 예외를 던지게
  설계된 메서드
- **상태 확인 메소드:** 클라이언트가 상태 의존적 메서드를 호출하기 전에 현재 클래스의 내부 상태가 해당 메서드를 호출하기에 **유효한지를 미리 검사**할 수 있도록 제공되는 메서드