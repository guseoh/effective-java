### ✅ public 클래스에는 public 필드가 아닌 접근자 메서드를 사용하라

## 0. 들어가기 전
> 객체지향의 사실와 오해에서는 이렇게 객체지향의 본질을 정의한다.
- 객체지향이란 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고 객체를 이용해 시스템을 분할하는 방법이다.
- 자율적인 객체란 `상태(state)`와 `행위(behavior)`를 함께 지니며 스스로 자기 자신을 책임지는 객체를 의미한다.
- 객체는 시스템의 행위를 구현하기 위해 다른 객체와 협력한다.
- 각 객체는 협력 내에서 정해진 역할을 수행하며 역할은 관련된 책임의 집합이다.
- 객체는 다른 객체와 협력하기 위해 메시지를 전송하고, 메시지를 수신한 객체는 메시지를 처리하는데 적합한 메서드를 자율적으로 선택한다.

### 0.1 자율적인 객체를 보장해 줄 수 있는 것은 바로 캡슐화이다.
- 캡슐화는 객체의 상태, 메서드를 하나로 묶고, 실제 구현 내용을 외부에 감추는 것이다.
- 외부 객체는 객체 내부의 구조를 얻지 못하며 객체가 노출해서 제공하는 필드와 메서드만 사용 가능하다.
- 캡슐화의 이유는 객체에게 자율성을 보장하기 위함이다.
- 자바는 이를 위해 `접근 제어자(Access Modifier)`를 사용하고 있다.

## 1. 왜 public 필드가 문제인가?
자바의 객체지향 설계 원칙 중 하나는 `캡슐화(encapsulation)` 이다.

캡슐화란 **객체의 내부 상태와 구현을 외부로부터 숨기고, 필요한 부분만 노출하는 것**을 의미한다.

```java
public class Point {
    public double x;
    public double y;
}
```
겉보기에는 단순하고 편리해 보이지만, 다음과 같은 문제들이 발생한다.

<br>

### 1.1 내부 표현이 API의 일부가 되는 문제

자바 클래스에서 필드를 `public`으로 노출하는 순간, 그 필드의 존재와 구조는 그대로 외부 API의 일부가 된다.

예를 들어, 2차원 좌표를 표현하는 `Point` 클래스가 `x`와 `y`라는 `public` 필드를 갖고 있다고 가정할 경우 이렇게 설계하면 외부의 모든 코드가 `point.x`와 `point.y`를 직접 읽고 쓸 수 있다.

문제는 시간이 지나 **내부 구현 방식을 바꾸고 싶을 때 발생**한다. 만약 우리는 `(x, y)` 대신 극좌표계 `(redius, angle)`로 좌표를 저장하고 싶다고 결정했다면, 기존의 public 필드를 유지하지 않는 이상 기존 API와 호환되지 않게 된다.

<details>
    <summary>필드 이름과 타입이 그대로 외부 계약의 일부이기 때문에, 내부 구현 변경이 사실상 불가능해지는 것이다.</summary>
<div markdown="1">

1. 외부 계약이란?
- **외부 코드가 해당 클래스를 어떻게 사용해야 하는지를 정의하는 약속**이다.
- 클래스가 **public 메서드, public 필드, 상수** 등 외부에서 접근 가능한 모든 요소가 계약의 일부가 된다.
- API 계약은 한 번 공개하면 변경이 어렵다. 변경 시 외부에서 그 API를 사용하던 모든 코드가 수정되어야 하기 때문이다.


2. 왜 필드 이름과 타입이 계약이 되는가?

예를 들어, 다음과 같이 Point 클래스에 public 필드가 있다고 하자.

```java
public class Point {
	public double x;
	public double y;
}
```

- 이 클래스가 공개되면, 외부 코드에서는 다음과 같이 직접 접근이 가능해진다.

```java
Point p = new Point();
p.x = 3.0;
p.y = 4.0;
System.out.println(p.x + ", " + p.y);
```

- `x`와 `y`라는 이름과 `double` 이라는 타입이 외부 코드에 직접 노출된다.
- 따라서, 나중에 `Point`의 내부 표현을 `redius`와 `angle`로 바꾸거나, `double` 대신 `BigDecimal`로 변경하고 싶어도 **이미 외부에서 `p.x` 형태로 쓰고 있기 때문에 API를 깨뜨리게 된다.**


3. 변경이 불가능해진 이유
- 외부 코드가 이미 `p.x`와 `p.y`를 직접 참조하고 있으므로, 필드명을 변경하거나 타입을 바꾸면 **컴파일 오류**가 발생한다.
- 내부적으로 다른 방식으로 데이터를 저장하려 해도, 외부에서는 여전히 기존 필드가 존재해야 하므로, **구조적인 변경이 사실상 막혀버린다.**
- 반대로, 필드가 `private`이고 `getX()`, `getY()` 같은 메서드로 제공된다면, 내부 구현을 `(redius, angle)` 로 바꾼 후에도 메서드 내부 로직만 수정하면 외부 코드는 전혀 수정할 필요가 없다.


4. 정리

public 필드는 **이름과 타입이 외부 코드와 강하게 결합**되므로, 한 번 공개하면 내부 구조를 바꾸는 순간 외부 코드와의 호환성이 깨진다. 이 때문에 유지보수나 확장이 매우 어려워지고, API 설계의 유연성이 사라지게 된다.
</div>
</details>

<br>

### 1.2 데이터 무결성 유지의 어려움

public 필드는 데이터 무결성을 지키기 어렵게 만든다. 외부 코드가 해당 값을 직접 수정할 수 있으니, 잘못된 데이터가 들어가는 것을 막을 방법이 없다.

예를 들어, 좌표 값이 절대 음수가 되어서는 안 된다는 규칙이 있다고 가정할 때 이 규칙을 지키려면 값을 설정할 때 검증 로직이 필요하지만, public 필드 구조에서는 이를 강제할 수 없다.

외부에서 단순히 `point.x = -5;` 처럼 코드를 작성해버리면, 클래스 내부의 불변식(invariant)이 손쉽게 깨져버린다.

<details>
    <summary>데이터 무결성</summary>
<div markdown="1">

- 데이터가 정확하고, 완전하며, 일관성을 유지하는 상태
</div>
</details>

<br>

### 1.3 동기화나 부가 로직 추가의 제약

public 필드를 사용하면 값 읽기와 쓰기가 메서드 호출이 아닌 **직접 접근 방식**으로 이뤄진다. 이 경우, 동기화 코드를 삽입하거나 로그 기록·계산 처리 같은 부가 동작을 추가하는 것이 불가능해진다.

예를 들어, 여러 스레드가 동시에 값을 읽고 쓸 수 있는 환경에서, 접근자 메서드가 있다면 `synchronized` 키워드나 Lock을 활용해 안전하게 제어할 수 있다. 그러나 public 필드 구조에서는 이러한 제어 지점을 만들 수 없으므로, 멀티스레드 환경에서 안정성을 보장하기 어렵다.

<br>

## 2. 접근자 메서드 사용

위 문제를 해결하는 방법은 필드를 **private으로 숨기고, getter/setter 메서드로 접근을 제어**하는 것이다.
```java
public class Point {
    private double x;
    private double y;

    public double getX() { return x; }
    public double getY() { return y; }

    public void setX(double x) {
        if (x < 0) throw new IllegalArgumentException("x 좌표는 음수일 수 없습니다.");
        this.x = x;
    }

    public void setY(double y) {
        if (y < 0) throw new IllegalArgumentException("y 좌표는 음수일 수 없습니다.");
        this.y = y;
    }
}
```

<br>

### 2.1 값 검증 기능 - 잘못된 값 차단

`public` 필드는 외부에서 누구든 바로 값을 변경할 수 있으므로, 음수 좌표, 유효 범위를 벗어난 값, null 등 잘못된 데이터가 들어오는 것을 막을 방법이 없다.

하지만 `setter` 메서드를 사용하면 값이 변경되는 순간 유효성 검사를 넣을 수 있다.
```java
public void setX(int x) {
    if (x < 0) {
        throw new IllegalArgumentException("좌표 x는 음수가 될 수 없습니다.");
    }
    this.x = x;
}
```
이렇게 잘못된 상태로 객체가 존재하는 일을 원천적으로 방지할 수 있어, 시스템 안전성이 크게 향상된다.

<br>

### 2.2 내부 표현 변경 가능 - API 호환성 유지

`public` 필드로 노출하면, 필드 이름과 타입이 외부 API 계약의 일부가 된다. 즉, 내부 구현을 `(x, y)` 좌표에서 `(redius, angle)` 같은 극좌표 방식으로 바꾸려면, API를 사용하는 모든 외부 코드까지 전부 수정해야 한다.

반면, `getter`와 `setter`를 사용하면, 내부 저장 구조를 변경해도 메서드 시그니처만 유지하면 외부 API 호환성이 깨지지 않는다.

예를 들어, 내부에서는 `(redius, angle)`로 저장하지만, `getX()`에서 계산해서 반환하면, 외부에서는 여전히 기존 방식처럼 `point.getX()`로 접근할 수 있다.

이 덕분에 내부 구현을 바꿔도 API를 사용하는 코드에는 영향이 없다.

<br>

### 2.3 동기화/로직 삽입 가능 - 확장성 확보

만약 객체의 필드 접근이 멀티스레드 환경에서 이뤄진다면, 동기화(synchronization)가 필요할 수 있다.

`public` 필드는 접근 시 제어할 방법이 전혀 없지만, 메서드를 사용하면 필요할 때 동기화를 추가하거나 로깅, 캐싱, 이벤트 트리거 같은 부가 로직을 넣을 수 있다.
```java
public synchronized void setY(int y) {
    this.y = y;
    System.out.println("Y 값이 변경되었습니다: " + y);
}
```
이렇게 하면 **데이터 접근 시점에 필요한 추가 작업을 언제든 쉽게 추가**할 수 있다.

<br>

## 3. public 필드를 허용하는 예외 상황

일반적으로 공개 API를 구성하는 클래스에서는 public 필드를 사용하지 말라고 권고한다. 

하지만 예외적으로, **클래스가 외부에 노출되지 않는 범위 내에 있을 때**는 public 필드를 사용하는 것이 오히려 설계와 구현을 간겨라게 하는 데 도움이 된다.

<br>

### 3.1 패키지 전용 클래스(package-private class)

이 클래스는 **같은 패키지 내에서만 접근 가능하며 외부 API가 아니다**. 

따라서 내부 구현이 외부에 노출될 위험이 적고, 엄격한 캡슐화가 반드시 필요한 상황이 아니다. 이런 경우, 필드를 `public`으로 선언하면 코드가 단순해지고 불필요한 접근자 메서드를 만들 필요가 없어서 편리하다.

예를 들어 아래 코드를 보면, `Coordinate` 클래스는 접근 제한자가 없어서 같은 패키지 안에서만 사용 가능하다. `x`와 `y` 필드를 `public`으로 선언했는데, 이는 외부에 노출되지 않기 때문에 캡슐화 원칙에 어긋나지 않는다.
```java
// 패키지 전용 클래스 예시
class Coordinate {
    public int x;
    public int y;

    Coordinate(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
```

<br>

### 3.2 private 중첩 클래스(private nested class)

이 경우 클래스 자체가 **외부에 완전히 숨겨져 있으므로, 내부 구현을 간결하고 효율적으로 표현하기 위해 public final 필드를 사용할 수 있다.** public 필드이지만 외부에서 접근할 수 없으므로 캡슐화가 유지된다.

아래 예시에서 `Coordinate` 클래스는 `OuterClass` 내부에 private static 중첩 클래스로 선언되어 있다. `x`와 `y`는 public final 필드로 선언되어, `Coordinate` 객체 생성 시 불변 데이터를 간단히 표현한다. 외부에서는 `OuterClass`의 메서드를 통해서만 좌표 정보에 접근할 수 있어 안전하다.
```java
public class OuterClass {
    // private 중첩 클래스
    private static class Coordinate {
        public final int x;
        public final int y;

        Coordinate(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    private Coordinate point = new Coordinate(3, 4);

    public int getX() {
        return point.x;
    }

    public int getY() {
        return point.y;
    }
}
```

## 4. 정리

- **공개 API의 클래스라면 public 필드는 절대 피하라**
- 대신 **private 필드 + 접근자 메서드** 조합을 사용해 변경 가능성과 안전성을 확보하라
- 단, **패키지 전용 클래스나 private 중첩 클래스**처럼 외부에 노출되지 않는 경우는 예외적으로 허용 가능하다.