### ✅ 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라

마커 인터페이스란 자신을 구현하는 클래스가 특정 속성(분류)을 가짐을 나타내는 인터페이스로,
추상 메서드, 필드, `default`, `static` 메서드 등 아무것도 포함하지 않습니다. 대표적인 예시로는 `Cloneable`과 `Serializable` 인터페이스가 있습니다.

### 마커 인터페이스 vs 마커 어노테이션

1. 마커 인터페이스는 이를 구현한 클래스의 인스턴스를 구분하는 **타입**으로 사용 가능  
   <br />
   인터페이스도 어엿한 타입이기 때문에 마커 어노테이션을 사용했다면 런타임에 발견될 오류를 컴파일 시점에 잡을 수 있습니다.  
   <br />
   예를 들어,`Serializable` 마커 인터페이스는 객체가 직렬화될 수 있음을 나타냅니다.
   다음 코드를 보면, `serialize()` 메소드는 `Serializable` 타입을 요구합니다.

```java
public static void serialize(Serializable obj) {
}

public class NotSerializable {
}

public class Main {
    public static void main(String[] args) {
        NotSerializable obj = new NotSerializable();
        serialize(obj); // 컴파일 오류!
    }
}
```

`NotSerializable`은 `Serializable` 타입이 아닌 관계로 `serialize` 메소드 매개변수에 사용하면 컴파일 오류가 발생합니다.

2. 적용 대상을 더 정밀하게 지정 가능  
   마커 인터페이스는 **타입 계층 구조**를 활용해 적용 대상을 더 정밀하게 지정할 수 있습니다. 예를 들어, 특정 인터페이스를 확장한 클래스에만 마커 인터페이스를 적용함으로써 그 **하위 타입 전체에 특정한
   속성을 부여**할 수 있습니다.
   <br />  
   반면, 어노테이션은 @Target 옵션을 통해 클래스, 인터페이스, 열거 타입 등을 지정할 수 있지만, 타입 계층을 이용해 특정 하위 타입에만 적용하는 방식은 지원하지 않습니다.

### 그럼 마커 어노테이션은 언제 사용할까요??

일반적으로 모듈화한 코드를 어노테이션으로 적용하고 싶을 때 자주 사용합니다. 이 경우 코드의 가독성과 일관성을 높일 수 있습니다.

정리하자면

- 타입 체크와 계층 구조 활용이 필요하다면 → 마커 인터페이스
- 단순 속성 표시(태그, 꼬리표라고 생각하면 편하실 듯)와 모듈화 코드 적용이 목적이라면 → 마커 애노테이션

