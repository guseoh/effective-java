### ✅ wait와 notify 보다는 동시성 유틸리티를 애용하라

### 들어가기 전

`wait()`와 `notify()`는 쓰레드의 상태를 제어하기 위한 메서드로 `wait()`는 **내부 락을 해제하고 쓰레드를 일시 정지 상태로 만드는 메서드**이며,
`notify()`는 **대기 중인 쓰레드들 중 하나를 임의로 선택해 실행 가능 상태로 깨우는 메서드**입니다.

### 동시성 유틸리티의 등장 배경

자바 5에 도입된 고수준 동시성 유틸리티가 이전에는 `wait`와 `notify`로 하드코딩해야 했던 전형적인 일들을 대신 처리해주면서
이제는 `wait`와 `notify`를 사용해야 할 이유가 크게 줄었습니다.
그리고 올바르게 사용하기가 아주 까다로운 이 메서드들 대신 고수준 동시성 유틸리티를 사용하는 것이 좋습니다.

#### 고수준 동시성 유틸리티 구성

1. 실행자 프레임워크 (Executor Framework) - 아이템 80에서 다룸
2. 동시성 컬렉션 (Concurrent Collections)
3. 동기화 장치 (Synchronizer)

### 동시성 컬렉션 - Concurrent Collections

동시성 컬렉션은 `List`, `Queue`, `Map` 같은 표준 컬렉션 인터페이스에 동시성 작업을 추가해 만든 고성능 컬렉션입니다.
이 컬렉션들은 여러 쓰레드가 동시에 안전하게 접근할 수 있도록 동기화 처리를 스스로 내부에서 수행합니다.  
따라서 개발자가 **외부에서 이 컬렉션의 동시성을 억지로 막거나 깨뜨리려 하는 것은 불가능**하며,
오히려 **외부에서 락을 추가로 걸게 되면 속도만 느려**지게 됩니다.

#### 동시성 컬렉션 메소드 특징

동시성 컬렉션은 `put()`, `get()`, `size()`와 같은 **개별 메서드마다 효율적인 동기화(락)** 를 이미 갖추고 있어
여러 쓰레드가 동시에 안전하게 접근할 수 있도록 설계되어 있지만 이러한 메서드들을 조합해 연속적으로 호출할 경우
그 사이에 다른 쓰레드가 개입할 수 있어 [원자성](https://view471.tistory.com/m/45)이 깨지게 됩니다.
즉, 동시성 컬렉션은 각 메서드 단위의 원자성만 보장할 뿐 **둘 이상의 메서드를 연달아 호출하는 상황에서는 원자성을 보장하지 않습니다.**

#### 상태 의존적 수정 메소드

이러한 원자성 문제를 해결하기 위해 여러 기본 동작을 하나의 원자적 동작으로 묶어주는 **'상태 의존적 수정' 메서드**들이 동시성 컬렉션에 추가되었습니다.
이 메서드들은 이후 자바 8에서 일반 컬렉션 인터페이스에도 **디폴트 메서드 형태**로 도입되었습니다.

#### 코드 예시 - 성능 차이

상태 의존적 수정 메서드가 동일한 동작을 수행하더라도, 조회 작업을 어떻게 처리하느냐에 따라 성능 차이가 발생할 수 있습니다.

```java

public class Item81 {

    private static final ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();

    public static String intern1(String s) {
        String s1 = map.putIfAbsent(s, s);
        return s1 == null ? s : s1;
    }

    public static String intern2(String s) {
        String result = map.get(s);

        if (result == null) {
            result = map.putIfAbsent(s, s);
            if (result == null) {
                result = s;
            }
        }

        return result;
    }
}

```

`intern1()`은 키의 존재 여부와 상관없이 항상 `map.putIfAbsent(s, s)`를 호출합니다.
따라서 **키가 이미 존재하더라도**, 내부적으로 락을 획득하고 검사를 진행한 후 해제하기 때문에 불필요한 오버헤드가 발생합니다.

반면, `intern2()` 메서드는 먼저 `get()`으로 조회를 시도하고, 값이 없을 때만 `putIfAbsent()`를 수행합니다.
`get()`은 `ConcurrentHashMap`의 특징으로 락을 사용하지 않고 읽기 작업을 허용하도록 최적화되어 있기 때문에
빠르게 값을 반환하고 불 필요한 자원을 소모하지 않습니다.  
결과적으로, 락 경합(lock contention) 을 줄이고 성능 향상을 얻을 수 있습니다.

#### 정리

상태 의존적 수정 메서드 중 조회 기능까지 지원하는 메서드가 있는데 단순히 조회만 하는 로직에서는 사실상 동시성을 크게 신경 쓸 필요가 없습니다.
따라서 `intern2()`처럼 **락을 사용하지 않는 메서드(get())** 를 먼저 사용하여 상태를 확인하는 것이 전체 시스템 성능 측면에서 훨씬 좋습니다.

#### 번외

추가적으로 일부 동시서 컬렉션 메소드는 작업이 성공적을 완료될 때까지 기다리도록 설계되었습니다. 예를 들어, `BlockingQueue.take()`

### 동기화 장치 - Synchronizer

동기화 장치는 여러 쓰레드가 서로의 실행 시점을 조율하고 협력하도록 도와주는 동시성 유틸리티로,
쓰레드 간의 **실행 순서나 조건을 제어하는 역할**을 수행하며, 여러 쓰레드가 동시에 실행되는 환경에서 발생하는 복잡한
상황들을 단순화하고 특정 지점에서 쓰레드들을 멈추거나 동시에 출발시키는 등 정확한 시점에 실행을 동기화하는 데 사용됩니다.

#### 주요 예시

- CountDownLatch - 자주 사용
- Semaphore - 자주 사용
- CyclicBarrier
- Exchanger
- Phaser - 가장 강력

[자세한 내용](https://medium.com/%40japleen.kaur11/java-concurrency-choosing-between-countdownlatch-cyclicbarrier-phaser-and-semaphore-8ab855d570f6)

<br/>  

#### wait와 notify 대신 동기화 장치(CountDownLatch) 사용하는 이유

1. **오류 발생 가능성 감소**

`wait`과 `notify`를 직접 사용하는 방식은 매우 섬세한 코드 작성이 요구됩니다.
예를 들어, 올바른 호출 위치, 조건 검사 반복 (while 루프 구조), `notifyAll()` 사용, 허위 각성(spurious wakeup) 현상 등 많은 주의를 기울여야 하며
정상 동작을 보장하려면 실수할 여지가 많습니다.

`CountDownLatch`는 이러한 복잡한 제어 로직을 내부에서 안전하게 처리하므로
개발자는 오직 '언제 기다릴지(`await()`), 언제 신호를 보낼지(`countDown()`)'만 명시하면 됩니다.
결과적으로 코드의 안정성이 높아지고, 오류 가능성이 현저히 줄어듭니다.

2. **안정성 / 간결함**

`synchronized`, `wait`, 그리고 `notify`를 사용하는 패턴은 이해와 유지보수가 어렵고 작은 실수 하나로도 시스템 전체가 멈출 수 있는
반면 `CountDownLatch`와 같은 동기화 장치는 명확한 역할과 훌륭한 인터페이스를 제공하여 복잡한 **❗쓰레드 제어를 추상화된 방식으로 표현❗**할 수 있게 됩니다.
그 결과 동기화 장치의 설계된 추상화 덕분에 사용이 편리하고 코드의 가독성이 향상되어 동시성 로직이 직관적으로 이해 가능한 형태로 바뀌며 버그 발생 가능성까지 감소합니다.

