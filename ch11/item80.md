## ✅ 스레드보다는 실행자, 태스크, 스트림을 애용하라

## 1. 실행자 프레임워크(Executor Framework)

- java.util.concurrent 패키지가 나오기 이전에는 작업 큐를 사용하려면 안전 실패나 응답 불가능한 문제를 해결하기 위한 코드를 추가해야 했다.
- java.util.concurrent가 등장하면서 실행자 프레임워크를 제공한다.
- 실행자 프레임워크는 **작업(task) 제출**과 **실행(execution)** 을 분리한 구조다.
    - 즉, “무엇을 할지”와 “어떻게 실행할지”를 독립적으로 관리한다.
```java
ExcecutorService exec = Executors.newSingleThreadExecutor();

exec.execute(runnable);
exec.shutdown();
```

- `ExcecutorService` : 작업을 실행하는 주체(스레드 풀)
- `execute`: 실행할 태스크(작업)을 넘기는 방법
- `shutdown` : 실행자를 우아하게 종료시키는 방법 (이 작업이 실패하면 VM 자체가 종료되지 않을 것이다.)
- 애플리케이션은 작업을 제출만 하고, 실제 실행은 프레임워크가 담당한다.
    - 개발자는 스레드 생명주기나 리소스 관리를 신경 쓰지 않아도 된다.

<br>

### 실행자 서비스의 주요 기능

- 특정 태스크가 완료되기를 기다린다.
- 태스크 모음 중 아무것 하나(invokeAny 메서드) or 모든 태스크(invokeAll 메서드)가 완료되기를 기다린다.
- 실행자 서비스가 종료하기를 기다린다(awaitTermination 메서드).
- 완료된 태스크들의 결과를 차례로 받는다(ExecutorCompletionService 이용).
- 태스크를 특정 시간에 혹은 주기적으로 실행하게 한다(ScheduledThreadPollExecutor 이용).

<br>

## 2. 스레드 풀

- 스레드 풀은 스레드 관리를 효율적으로 처리하여 작업을 동시에 처리하도록 돕는다.
    - 큐 같은 자료구조를 가진 클래스에 쓰레드를 미리 만들어서 놓는 것이다.
    - 즉, 매번 `new Thread()`로 새 스레드를 만드는 대신, 한정된 수의 스레드를 미리 만들어두고 필요할 때 빌려 쓰는 구조
- 스레드 풀의 스레드 개수는 고정할 수도 있고 필요에 따라 늘어나거나 줄어들게 설정할 수 있다.
- java.util.concurrent.Executors의 정적 팩터리 메서드를 사용하여 원하는 스레드 풀을 생성할 수 있다.
    - 작은 프로그램이나 가벼운 서버 → `Executors.newChchedThreadPool`
    - 무거운 프로덕션 서버 → `Executors.newFixedThreadPool`
- 특별한 실행자를 원한다면 ThreadPoolExecutor 클래스를 사용할 수 있다.
    - 스레드 풀의 동작을 거의 모든 측면에서 설정하고 관리할 수 있는 클래스이다.
    - 스레드 풀의 크기, 작업 큐의 종류, 스레드 생성, 스레드 종료 규칙 등을 세밀하게 제어할 수 있다.

<details>
    <summary>스레드 풀의 동작 원리</summary>
<div markdown="1">

```java
┌──────────────────────────┐
│     Thread Pool          │
│ ┌───────────────┐        │
│ │ Worker Thread │        │
│ │ Worker Thread │        │
│ │ Worker Thread │        │
│ └───────────────┘        │
│         ↑                │
│   ┌───────────────┐      │
│   │ Task Queue     │ ← 새로운 작업이 들어옴
│   └───────────────┘      │
└──────────────────────────┘
```

1. 새로운 작업(Task)이 들어오면
2. 풀 안에 대기 중인 스레드가 즉시 실행
3. 모든 스레드가 바쁘면, 작업은 큐(queue)에 저장
4. 스레드가 작업을 끝내면 큐에서 다음 작업을 꺼내 실행
</div>
</details>

<br>

## 3. Runnable와 Callable

- **작업 큐를 손수 만드는 일은 삼가야 하고, 스레드를 직접 다루는 것도 일반적으로 삼가야 한다.**
- 스레드를 직접 다루면 Thread가 작업 단위와 수행 메커니즘 역할을 모두 수행하게 된다.
- 반면 실행자 프레임워크는 **작업 단위**와 **실행** 메커니즘이 분리된다.
    - 작업 단위를 나타내는 핵심 추상 개념이 `태스크(task`)다.
- task는 `Runnable`과 `Callable`이라는 두 가지 종류가 있다.
    - `Callable`은 `Runnable`와 비슷하지만 값을 반환하고 임의의 예외로 던질 수 있다.
- 실행자 서비스는 이러한 task를 실행하는 역할을 한다.
- 태스크 수행을 실행자 서비스에 맡기면 원하는 태스크 수행 정책을 선택할 수 있고, 생각이 바뀌면 언제든 변경할 수 있다.
- 즉, 서비스에 작업을 맡기면 프레임워크가 작업을 스레드에 할당하고, 작업이 완료되면 결과를 돌려준다.

<br>

## 4. 포크-조인(fork-join)

- 자바 7이 되면서 실행자 프레임워크는 포크-조인(fork-join) 태스크를 지원하도록 확장되었다.
- 포크-조인 태스크는 포크-조인 풀이라는 특별한 실행자 서비스가 실행해준다.
- `ForkJoinTask`의 인스턴스는 작은 하위 태스크로 나뉠 수 있고, `ForkJoinPool`을 구성하는 스레드들이 이 태스크들을 처리하며,
    - 일을 먼저 끝낸 스레드는 다른 스레드의 남은 태스크를 가져와 대신 처리할 수도 있다.
- 이렇게 모든 스레드가 바쁘게 움직여 CPU를 최대한 활용하면서 높은 처리량과 낮은 지연시간을 달성한다.
- 포크-조인 태스크를 직접 잘 작성하는 것은 어려우나,
    - 포크-조인 풀을 이용해 만든 병렬 스트림(아이템 48)을 이용하면 적은 노력으로 그 이점을 얻을 수 있다.