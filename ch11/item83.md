### ✅ 지연 초기화는 신중히 사용하라

> 지연 초기화에 최선의 조언: 필요할 때까지는 하지 말라 - 아이템 67

지연 초기화(lazy initialization)는 객체나 값의 생성을 실제로 필요해지는 시점까지 미루는 초기화 기법입니다.
그렇게 해서 불필요한 비용을 줄이고 초기화 때 발생하는 위험한 순환 문제를 해결하는 효과도 있습니다.

### 지연 초기화의 장점 및 단점

지연 초기화는 **필요할 때만 초기화**하여 자원을 효율적으로 관리하는 기법이지만 항상 최적의 성능을 보장하는 것은 아닙니다.

#### 장점

- **시작 시간 단축:** 앱 부팅·객체 생성 시 불필요한 초기화를 미룸
- **자원 절약:** 실제로 필요할 때만 사용
- **드문 경로 최적화:** 일부 코드 경로에서만 쓰는 값은 아예 만들지 않을 수 있음

#### 단점

- **첫 접근 지연:** 처음 쓰는 순간 latency가 발생
- **지속적 접근 시 오버헤드 발생:** `null` 체크, `volatile` 읽기, 프록시 호출 등 미세 비용 누적
- **동시성 복잡도:** `DCL`, 락, 가시성(volatile) 등 쓰레드 안전 처리 필요
- **예측 어려움:** 어떤 경로에서 실제로 초기화될지/언제 될지 파악이 어려움

#### 지연 초기화의 핵심 기준

지연 초기화의 효과는 **얼마나 자주 쓰이는가** 와 **초기화에 얼마나 많은 리소스가 필요한지** 에 따라 이득/손해가 결정됩니다.

- 초기화 비용: 초기화하는 데 드는 리소스가 클수록 지연 초기화의 이득이 커집니다.
- 사용 빈도: 해당 필드가 결국 초기화되지 않을 확률이 높을수록 이득이 큽니다.
- 호출 빈도: 초기화가 된 후에 해당 필드를 얼마나 빈번히 호출하는가에 따라 추가적인 접근 비용 오버헤드가 누적될 수 있습니다.

### 지연 초기화가 필요한 순간

지연 초기화의 근본적인 목적은 성능 이점을 얻는 것이지만 이는 양날의 검과 같아서
초기화 비용이 크고 실제로 사용 및 호출되는 빈도가 낮은 특정 필드에서만 진정한 이득을 볼 수 있습니다.
아쉽게도 지연 초기화가 제 역할을 해줄 수 있을지 여부를 확실히 판단할 수 있는 **유일한 방법은 지연 초기화 적용 전후의 성능을 직접 측정**해 보는 것입니다.

단❗ 대부분의 상황에서 일반적인 초기화가 지연 초기화보다 낫습니다.

### 초기화 순환성 문제

지연 초기화 **초기화 순환성(Initialization Circularity)** 이란 두 개 이상의 클래스나 객체가 서로를 초기화하는 과정에서 상호 의존성을 가지면서
발생하는 문제를 말합니다.

쉽게 말해 A를 만들려면 B가 필요하고, 동시에 B를 만들려면 A가 필요한 상황이 발생하여,
시스템이 어느 쪽도 먼저 만들지 못하고 멈추거나 예상치 못한 오류가 발생하는 것입니다.

```java
// 일반적인 초기화 방법
private final FieldType field = computeFieldValue();

// synchronized를 이용한 동기화 방식
private FieldType field;

private synchronized FieldType getField() {
    if (field == null) {
        field = computeFieldValue();
    }
    return field;
}
```

이렇게 간단하게 해결할 수 있습니다. 초기화 순환성 문제에 핵심은
멀티 쓰레드 환경에서 여러 쓰레드가 동시에 접근할 때 문제가 발생합니다. 즉, 동기화 관련 코드를 작성하면 해당 문제는 해결 됩니다.

### 문제 해결. 지연 초기화 홀더 클래스 관용구(패턴) - 정적 필드

성능 때문에 **정적 필드**를 지연 초기화해야 한다면 지연 초기화 홀더 클래스 관용구를 사용하면 됩니다. 클래스는 클래스가 처음 쓰일 때
비로소 초기화된다는 특성을 이용한 기법입니다.

```java
private static class FieldHolder {
    static final FieldType field = computeFieldValue();
}

private static FieldType getField() {
    return FieldType.field;
}


```

지연 초기화 홀더 클래스 패턴에서는 `getField()` 메서드가 **처음 호출되는 순간** `FieldHolder.field` 처음으로 읽히면서,
비로소 `FieldHolder` **클래스의 초기화를 촉발해 초기화 시점을 지정**할 수 있습니다.

이 패턴의 가장 큰 장점은 `getField()` 메서드가 필드에 접근할 때 **별도의 동기화(Synchronization) 처리를 전혀 하지 않아**
성능 저하를 일으킬 여지가 없다는 것입니다. 이는 **일반적인 가상 머신(Virtual Machine)**
이 오직 클래스를 초기화하는 시점에만 필드 접근을 **자동으로 동기화**하도록 설계되어 있기 때문입니다.
클래스 **초기화가 완료된 후에는 가상 머신이 내부적으로 동기화 코드를 제거**하여, 그 다음부터는 어떠한 추가적인 검사나 동기화 과정 없이 빠르게 필드에 접근할 수 있게 됩니다.

### 문제 해결. 이중 검사 관용구(패턴) - 인스턴스 필드

성능을 이유로 **인스턴스 필드**를 지연 초기화할 때는 **이중 검사 패턴(Double-Checked Locking)** 을 사용해야 하며,
이 패턴은 필드가 초기화된 후에는 접근 시 동기화 비용을 완전히 제거하여 성능 이점을 극대화합니다.

```java
private volatile FieldType field;

private FieldType getField() {
    FieldType result = field;
    if (result != null) { // 첫번째 검사 - 락 사용 안함
        return result;
    }

    synchronized (this) {
        if (field == null) { // 두번째 검사 - 락 사용
            field = computeFieldValue();
        }

        return field;
    }
}
```

이중 검사 패턴은 필드의 값을 **두 번 검사**하는 방식으로 동작합니다.
먼저 동기화 없이 첫 번째 검사를 수행하고, 만약 필드가 아직 초기화되지 않았다면 그때서야 `synchronized` 키워드를 사용하여 두 번째 검사를 진행합니다.
이 동기화된 영역 안에서 두 번째 검사를 통해서도 필드가 `null`일 때만 비로소 초기화 작업을 실행하게 됩니다.
초기화가 완료된 후에는 더 이상 동기화 과정을 거치지 않고 필드에 접근할 수 있도록 보장해야 하므로, 해당 필드는 반드시 **`volatile`** 로 선언되어야 합니다.

여기에 `result`라는 지역 변수를 사용하는 것은 선택 사항이지만, 성능을 높여주는 표준적인 동시성 프로그래밍 방법입니다. 이 변수는 **필드가 이미 초기화된 상황에서 필드의 값을 딱 한 번만 읽도록 보장**하는
역할을 하며, 책에서 지역 변수를 사용하지 않을 때보다 약 1.4배 빠르게 동작하는 성능 이점을 제공합니다.

#### 번외. 단일 검사 관용구(패턴)

가끔 굳이 이중 검사 패턴을 사용하지 말고 단일 검사 패턴만 사용해도 되는 경우가 있습니다. 단 인스턴스 필드는 volatile로 선언해야 합니다. 특정 상황에서는 굳이 복잡한 이중 검사 패턴을 사용하지 않고 단일
검사 패턴만으로도 충분히 지연 초기화를 구현할 수 있습니다. 다만, 이 경우에도 인스턴스 필드는 반드시 **`volatile`** 로 선언해야 합니다.

**초기화가 중복되어도 괜찮은 경우**
초기화 비용이 매우 크지 않거나, 초기화 로직(computeFieldValue())이 여러 번 실행되어도 프로그램의 동작에 전혀 문제가 없는
인스턴스 필드에 한정하여 사용됩니다.

```java
private volatile FieldType field;

private FieldType getField() {
    FieldType result = field;
    if (result == null) {
        field = result = computeFieldValue();
    }
    return result;
}
```

이러한 단일 검사 패턴에서도 인스턴스 필드는 반드시 **volatile**로 선언해야 합니다. 이는 초기화 작업이 완전히 완료되지 않은 불완전한
객체가 다른 스레드에 노출되어 예상치 못한 오류를 일으키는 것을 막기 위함입니다.  
다만, 이 패턴은 잠금이 없기 때문에 여러 스레드가 동시에 `getField()`를 호출하여 `if (result == null)` 검사를 통과할 경우,
초기화 작업(computeFieldValue())이 중복되어 실행될 수 있다는 점을 항상 염두에 두어야 합니다.