## ✅ 객체는 인터페이스를 사용해 참조하라

<br>

## 0. 들어가기 전
아이템 51에서 **매개변수 타입으로 클래스가 아니라 인터페이스를 사용하라**고 했다.

위 내용을 확장하여 “**객체는 클래스가 아닌 인터페이스로 참고하라**”로 확장 가능하다.

<br>

## 1. 매개변수, 반환값, 필드를 전부 인터페이스 타입으로 선언하라.
적합한 인터페이스가 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라.

**객체의 실제 클래스를 사용해야 할 상황은 오직 생성자로 생성할 때**뿐이다.

```java
// 좋은 예. 인터페이스를 타입으로 사용했다.
Set<Son> sonSet = new LinkedHashSet<>();

// 나쁜 예. 클래스를 타입으로 사용했다.
LinkedHashSet<Son> sonSet = new LinkedHashSet<>();
```

인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해질 것이다.  
나중에 구현 클래스를 교체하고자 한다면 그저 새 클래스의 생성자를 호출해주기만 하면 된다.

> 주의해야 할점
> >원래의 클래스가 특정 메서드를 제공하고, 그 메서드를 사용하는 코드가 있다면, 새로운 클래스도 반드시 그 메서드를 제공해야 한다.

예를 들어 `LinkedHashSet`은 순서를 가지는 반면, `HashSet`은 순서를 가지지 않는다. 원래 `LinkedHashSet`을 사용할 때, 순서에 의존적인 코드를 구현했다면 `HashSet`을 사용하더라도 같은 기능을 제공해야 한다.

<br>

## 2. 적합한 인터페이스가 없다면 당연히 클래스로 참조해야 한다.

첫 번째는 **String과 BigInteger 같은 값 클래스**가 그렇다. 값 클래스를 여러 가지로 구현될 수 있다고 생각하고 설계하는 일은 거의 없다.  
따라서 final인 경우가 많고 상응하는 인터페이스가 별도로 존재하는 경우가 드물다. 이런 값 클래스는 매개변수, 변수, 필드, 반환 타입으로 사용해도 무방하다.

두 번째는 **클래스 기반으로 작성된 프레임워크가 제공하는 객체(OutputStream 등)** 들이다. 클래스가 프레임워크의 기본적인 구성요소로 사용된다. 또한, 적합한 인터페이스가 거의 없다.  
따라서 클래스 타입을 직접 사용해야 할 수 있다.

세 번째는 **인터페이스에 없는 특별한 메서드를 제공하는 클래스(PriorityQueue 클래스)** 들이다. PriorityQueue 클래스는 Queue 인터페이스에 없는 comparator 메서드를 제공한다.  
이러한 메서드를 사용해야 하는 경우 클래스 타입을 직접 사용해야 한다.

> **적합한 인터페이스가 없다면 클래스의 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인(상위의) 클래스를 타입으로 사용하자.**